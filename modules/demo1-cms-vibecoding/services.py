"""
CMS Module Services - Generated by Vibecoding
Business logic layer for Content Management System
"""

import re
from datetime import datetime
from typing import List, Optional, Dict, Any
from uuid import uuid4

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func, text

# Import CMS models (would be available after module registration)
# from .models import CMSArticle, CMSCategory, CMSComment, CMSMedia


class CMSService:
    """
    Main service class for CMS operations
    Generated automatically by Vibecoding system
    """

    def __init__(self, db: AsyncSession):
        self.db = db

    # ========================================
    # ARTICLE SERVICES
    # ========================================

    async def create_article(self, article_data: Dict[str, Any], author_id: str, tenant_id: str) -> Dict[str, Any]:
        """
        Create a new article with SEO optimization
        Generated automatically by Vibecoding
        """
        # Generate slug from title
        slug = self._generate_slug(article_data.get("title", "untitled"))

        # Auto-generate SEO fields if not provided
        seo_title = article_data.get("seo_title") or article_data.get("title", "")[:60]
        seo_description = article_data.get("seo_description") or self._generate_excerpt(
            article_data.get("content", "")
        )

        # Set published_at if status is published
        published_at = None
        if article_data.get("status") == "published":
            published_at = datetime.utcnow()

        article = {
            "id": str(uuid4()),
            "tenant_id": tenant_id,
            "title": article_data.get("title", ""),
            "slug": slug,
            "content": article_data.get("content", ""),
            "excerpt": article_data.get("excerpt") or self._generate_excerpt(article_data.get("content", "")),
            "status": article_data.get("status", "draft"),
            "author_id": author_id,
            "category_id": article_data.get("category_id"),
            "tags": article_data.get("tags", []),
            "seo_title": seo_title,
            "seo_description": seo_description,
            "featured_image": article_data.get("featured_image"),
            "published_at": published_at.isoformat() if published_at else None,
            "created_at": datetime.utcnow().isoformat(),
            "updated_at": datetime.utcnow().isoformat()
        }

        # Mock database insertion
        # In real implementation: self.db.add(CMSArticle(**article)); await self.db.commit()

        return article

    async def get_articles(
        self,
        tenant_id: str,
        skip: int = 0,
        limit: int = 100,
        status_filter: Optional[str] = None,
        category_id: Optional[str] = None,
        search: Optional[str] = None
    ) -> List[Dict[str, Any]]:
        """
        Get articles with filtering and search
        Generated automatically by Vibecoding
        """
        # Mock implementation - in real implementation would query database
        articles = [
            {
                "id": "article-1",
                "tenant_id": tenant_id,
                "title": "Bienvenido a tu CMS",
                "slug": "bienvenido-cms",
                "content": "Contenido de ejemplo...",
                "excerpt": "Contenido de ejemplo...",
                "status": "published",
                "author_id": "user-1",
                "category_id": None,
                "tags": ["bienvenida", "cms"],
                "seo_title": "Bienvenido a tu CMS",
                "seo_description": "Primer artículo de tu sistema de gestión de contenido",
                "featured_image": None,
                "published_at": "2024-01-01T00:00:00Z",
                "created_at": "2024-01-01T00:00:00Z",
                "updated_at": "2024-01-01T00:00:00Z"
            }
        ]

        # Apply filters
        if status_filter:
            articles = [a for a in articles if a["status"] == status_filter]
        if category_id:
            articles = [a for a in articles if a["category_id"] == category_id]
        if search:
            search_lower = search.lower()
            articles = [
                a for a in articles
                if search_lower in a["title"].lower()
                or search_lower in a["content"].lower()
                or any(search_lower in tag.lower() for tag in a["tags"])
            ]

        return articles[skip:skip + limit]

    async def update_article(self, article_id: str, article_data: Dict[str, Any], tenant_id: str) -> Dict[str, Any]:
        """
        Update an existing article
        Generated automatically by Vibecoding
        """
        # Mock implementation
        updated_article = {
            "id": article_id,
            "tenant_id": tenant_id,
            "title": article_data.get("title", "Título actualizado"),
            "slug": self._generate_slug(article_data.get("title", "titulo-actualizado")),
            "content": article_data.get("content", "Contenido actualizado..."),
            "excerpt": article_data.get("excerpt", "Extracto actualizado..."),
            "status": article_data.get("status", "draft"),
            "author_id": "user-1",
            "category_id": article_data.get("category_id"),
            "tags": article_data.get("tags", ["actualizado"]),
            "seo_title": article_data.get("seo_title", "Título SEO actualizado"),
            "seo_description": article_data.get("seo_description", "Descripción SEO actualizada"),
            "featured_image": article_data.get("featured_image"),
            "published_at": article_data.get("published_at"),
            "created_at": "2024-01-01T00:00:00Z",
            "updated_at": datetime.utcnow().isoformat()
        }

        return updated_article

    async def delete_article(self, article_id: str, tenant_id: str) -> bool:
        """
        Soft delete an article
        Generated automatically by Vibecoding
        """
        # Mock implementation - in real implementation would update status
        return True

    # ========================================
    # CATEGORY SERVICES
    # ========================================

    async def create_category(self, category_data: Dict[str, Any], tenant_id: str) -> Dict[str, Any]:
        """
        Create a new category
        Generated automatically by Vibecoding
        """
        slug = self._generate_slug(category_data.get("name", "categoria"))

        category = {
            "id": str(uuid4()),
            "tenant_id": tenant_id,
            "name": category_data.get("name", ""),
            "slug": slug,
            "description": category_data.get("description", ""),
            "parent_id": category_data.get("parent_id"),
            "color": category_data.get("color", "#10B981"),
            "order_index": category_data.get("order_index", 0),
            "created_at": datetime.utcnow().isoformat()
        }

        return category

    async def get_categories_tree(self, tenant_id: str) -> List[Dict[str, Any]]:
        """
        Get categories in hierarchical tree structure
        Generated automatically by Vibecoding
        """
        # Mock implementation
        categories = [
            {
                "id": "cat-1",
                "name": "General",
                "slug": "general",
                "description": "Artículos generales",
                "parent_id": None,
                "color": "#10B981",
                "order_index": 0,
                "children": []
            },
            {
                "id": "cat-2",
                "name": "Tutoriales",
                "slug": "tutoriales",
                "description": "Guías y tutoriales",
                "parent_id": None,
                "color": "#3B82F6",
                "order_index": 1,
                "children": [
                    {
                        "id": "cat-3",
                        "name": "Python",
                        "slug": "python",
                        "description": "Tutoriales de Python",
                        "parent_id": "cat-2",
                        "color": "#10B981",
                        "order_index": 0,
                        "children": []
                    }
                ]
            }
        ]

        return categories

    # ========================================
    # MEDIA SERVICES
    # ========================================

    async def upload_media(self, file_data: Dict[str, Any], uploaded_by: str, tenant_id: str) -> Dict[str, Any]:
        """
        Upload and process a media file
        Generated automatically by Vibecoding
        """
        # Mock file processing
        media = {
            "id": str(uuid4()),
            "tenant_id": tenant_id,
            "filename": file_data.get("filename", "file.jpg"),
            "original_name": file_data.get("original_name", "file.jpg"),
            "mime_type": file_data.get("mime_type", "image/jpeg"),
            "file_size": file_data.get("file_size", 1024),
            "file_path": f"/uploads/{file_data.get('filename', 'file.jpg')}",
            "alt_text": file_data.get("alt_text"),
            "uploaded_by": uploaded_by,
            "created_at": datetime.utcnow().isoformat()
        }

        return media

    async def get_media_files(self, tenant_id: str, skip: int = 0, limit: int = 50) -> List[Dict[str, Any]]:
        """
        Get media files with pagination
        Generated automatically by Vibecoding
        """
        # Mock implementation
        media_files = [
            {
                "id": "media-1",
                "filename": "example.jpg",
                "original_name": "example.jpg",
                "mime_type": "image/jpeg",
                "file_size": 102400,
                "file_path": "/uploads/example.jpg",
                "alt_text": "Imagen de ejemplo",
                "uploaded_by": "user-1",
                "created_at": "2024-01-01T00:00:00Z"
            }
        ]

        return media_files[skip:skip + limit]

    # ========================================
    # SEARCH SERVICES
    # ========================================

    async def search_articles(self, query: str, tenant_id: str, limit: int = 20) -> List[Dict[str, Any]]:
        """
        Full-text search across articles
        Generated automatically by Vibecoding
        """
        # Mock search implementation
        if "cms" in query.lower() or "bienvenido" in query.lower():
            return [
                {
                    "id": "article-1",
                    "title": "Bienvenido a tu CMS",
                    "excerpt": "Contenido de ejemplo...",
                    "score": 0.95
                }
            ]

        return []

    # ========================================
    # COMMENT SERVICES
    # ========================================

    async def create_comment(self, comment_data: Dict[str, Any], article_id: str) -> Dict[str, Any]:
        """
        Create a new comment
        Generated automatically by Vibecoding
        """
        comment = {
            "id": str(uuid4()),
            "article_id": article_id,
            "content": comment_data.get("content", ""),
            "author_name": comment_data.get("author_name", "Usuario Anónimo"),
            "author_email": comment_data.get("author_email"),
            "parent_id": comment_data.get("parent_id"),
            "status": "pending",  # Requires moderation
            "created_at": datetime.utcnow().isoformat()
        }

        return comment

    async def get_article_comments(self, article_id: str, status: Optional[str] = None) -> List[Dict[str, Any]]:
        """
        Get comments for an article
        Generated automatically by Vibecoding
        """
        # Mock implementation
        comments = [
            {
                "id": "comment-1",
                "article_id": article_id,
                "content": "¡Excelente artículo!",
                "author_name": "Usuario Anónimo",
                "author_email": None,
                "parent_id": None,
                "status": "approved",
                "created_at": "2024-01-01T00:00:00Z"
            }
        ]

        if status:
            comments = [c for c in comments if c["status"] == status]

        return comments

    # ========================================
    # ANALYTICS SERVICES
    # ========================================

    async def get_analytics_overview(self, tenant_id: str) -> Dict[str, Any]:
        """
        Get comprehensive CMS analytics
        Generated automatically by Vibecoding
        """
        # Mock analytics
        analytics = {
            "total_articles": 1,
            "published_articles": 1,
            "draft_articles": 0,
            "total_views": 150,
            "total_comments": 1,
            "popular_categories": [
                {"name": "General", "count": 1},
                {"name": "Tutoriales", "count": 0}
            ],
            "recent_activity": [
                {
                    "type": "article_published",
                    "title": "Bienvenido a tu CMS",
                    "timestamp": "2024-01-01T00:00:00Z"
                }
            ],
            "seo_performance": {
                "average_score": 85,
                "articles_with_seo": 1,
                "articles_without_seo": 0
            }
        }

        return analytics

    # ========================================
    # SEO SERVICES
    # ========================================

    async def generate_seo_suggestions(self, title: str, content: str) -> Dict[str, Any]:
        """
        Generate SEO suggestions for content
        Generated automatically by Vibecoding
        """
        suggestions = {
            "seo_score": self._calculate_seo_score(title, content),
            "title_length": len(title),
            "content_length": len(content),
            "recommendations": self._generate_seo_recommendations(title, content),
            "meta_title_suggestion": self._optimize_meta_title(title),
            "meta_description_suggestion": self._generate_meta_description(content),
            "keyword_suggestions": self._extract_keywords(title + " " + content)
        }

        return suggestions

    # ========================================
    # UTILITY METHODS
    # ========================================

    def _generate_slug(self, title: str) -> str:
        """
        Generate URL-friendly slug from title
        """
        # Convert to lowercase and replace spaces with hyphens
        slug = title.lower().strip()
        slug = re.sub(r'[^\w\s-]', '', slug)  # Remove special characters
        slug = re.sub(r'[\s_-]+', '-', slug)  # Replace spaces and underscores with hyphens
        slug = slug.strip('-')

        # Ensure it's not empty
        if not slug:
            slug = "articulo"

        return slug

    def _generate_excerpt(self, content: str, max_length: int = 160) -> str:
        """
        Generate excerpt from content
        """
        if not content:
            return ""

        # Remove HTML tags (simplified)
        clean_content = re.sub(r'<[^>]+>', '', content)

        # Get first max_length characters
        excerpt = clean_content[:max_length]

        # Cut at word boundary
        if len(clean_content) > max_length:
            excerpt = excerpt.rsplit(' ', 1)[0] + "..."

        return excerpt

    def _calculate_seo_score(self, title: str, content: str) -> int:
        """
        Calculate SEO score (0-100)
        """
        score = 0

        # Title length (ideal: 30-60 chars)
        if 30 <= len(title) <= 60:
            score += 25
        elif 20 <= len(title) <= 70:
            score += 15

        # Content length (ideal: >300 words)
        word_count = len(content.split())
        if word_count > 300:
            score += 25
        elif word_count > 150:
            score += 15

        # Has keywords in title
        common_keywords = ["cms", "blog", "artículo", "contenido"]
        if any(keyword in title.lower() for keyword in common_keywords):
            score += 20

        # Has meta elements
        score += 15  # Assuming meta elements are present

        return min(100, score)

    def _generate_seo_recommendations(self, title: str, content: str) -> List[str]:
        """
        Generate SEO recommendations
        """
        recommendations = []

        if len(title) < 30:
            recommendations.append("Considera un título más largo (30-60 caracteres)")
        elif len(title) > 60:
            recommendations.append("El título es muy largo, considera acortarlo")

        word_count = len(content.split())
        if word_count < 150:
            recommendations.append(f"El contenido es corto ({word_count} palabras). Ideal: >300 palabras")

        if not any(keyword in title.lower() for keyword in ["cms", "blog", "contenido"]):
            recommendations.append("Considera incluir palabras clave relevantes en el título")

        if len(recommendations) == 0:
            recommendations.append("¡Excelente! El contenido está bien optimizado para SEO")

        return recommendations

    def _optimize_meta_title(self, title: str) -> str:
        """
        Optimize title for meta tags
        """
        if len(title) <= 60:
            return title
        return title[:57] + "..."

    def _generate_meta_description(self, content: str) -> str:
        """
        Generate meta description from content
        """
        excerpt = self._generate_excerpt(content, 160)
        return excerpt

    def _extract_keywords(self, text: str) -> List[str]:
        """
        Extract potential keywords from text
        """
        # Simple keyword extraction (in real implementation would use NLP)
        words = re.findall(r'\b\w{4,}\b', text.lower())
        word_freq = {}

        for word in words:
            if word not in ['para', 'con', 'por', 'una', 'del', 'las', 'los', 'este', 'esta', 'estos', 'estas']:
                word_freq[word] = word_freq.get(word, 0) + 1

        # Return top 5 keywords
        sorted_keywords = sorted(word_freq.items(), key=lambda x: x[1], reverse=True)
        return [keyword for keyword, _ in sorted_keywords[:5]]


# Factory function for service creation
def get_cms_service(db: AsyncSession) -> CMSService:
    """
    Factory function to create CMS service instance
    Generated automatically by Vibecoding
    """
    return CMSService(db)